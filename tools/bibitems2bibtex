#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
'''
Parses a number of bibitems into a proper BibTeX bibliography.  Since bibitems
don't have semantic information, certain heuristics have to be applied.
'''

import argparse
import re


def _main():
    '''Extra
    '''
    args = _parse_args()
    bibitem_strings = extract_bibitems(args.input)
    previous_author = None
    for bibitem_string in bibitem_strings:
        bibitem = parse_bibitem_string(bibitem_string)
        # If the author entry contains a vrule, assume that this is a
        # placeholder for the authors from the previous paper.
        if ('authors' in bibitem and '\\vrule' in bibitem['authors']
           and previous_author):
            bibitem['authors'] = previous_author
        entry = create_bibtex_string(bibitem)
        print(entry)
        if 'authors' in bibitem:
            previous_author = bibitem['authors']
        else:
            previous_author = None
    return


def clean(entry):
    '''Removes newlines and font specs from entries.
    '''
    new = entry
    new = entry \
        .replace('\n', ' ') \
        .replace('\\em ', '') \
        .replace('\\sc ', '') \
        .replace('~', ' ') \
        .strip()
    # Remove surrounding brackets
    if new[0] == '{' and new[-1] == '}':
        new = new[1:-1].strip()

    # Replace multiple white space by a simple space.
    new = re.sub('\s+', ' ', new)
    return new


def clean_pages(entry):
    new = clean(entry)
    m = re.match('^[^0-9]*([0-9]+[-]+[0-9]+).*', entry)
    if m and len(m.groups()) > 0:
        new = m.group(1) \
            .replace('--', '-')
    return new


def create_bibtex_string(bibitem):
    entries = []
    if 'authors' in bibitem:
        entries.append('  author = {%s}' % clean(bibitem['authors']))
    if 'title' in bibitem:
        entries.append('  title = {%s}' % clean(bibitem['title']))
    if 'journal' in bibitem:
        entries.append('  journal = {%s}' % clean(bibitem['journal']))
    if 'pages' in bibitem:
        entries.append('  pages = {%s}' % clean_pages(bibitem['pages']))

    entry = '@article{%s,\n%s\n}' % (bibitem['key'], ',\n'.join(entries))
    return entry


def my_split(s):
    '''Explodes a string around commas except when in a {}-environment.
    See <http://stackoverflow.com/a/26809037/353337>.
    '''
    parts = []
    bracket_level = 0
    current = []
    # trick to remove special-case of trailing chars
    for c in (s + ","):
        if c == "," and bracket_level == 0:
            parts.append("".join(current))
            current = []
        else:
            if c == "{":
                bracket_level += 1
            elif c == "}":
                bracket_level -= 1
            current.append(c)
    return parts


def parse_bibitem_string(bibitem_string):
    '''Parses a bibitem given as (multiline) string and returns semantic
    information. Of course, heuristics are needed.
    '''
    # Extract the reference key
    re.DOTALL
    regex = re.compile('^\\\\bibitem{(\w+)}\s*(.*)', re.DOTALL)
    m = re.match(regex, bibitem_string)

    # Explode the rest of the string around commas, except the commas
    # are enclosed in curly brackets (e.g., in the authors list).
    m2 = my_split(m.group(2))

    # Now the heuristics.
    bibitem = {
        'key': m.group(1),
        'authors': m2[0],
        'title': m2[1],
        }
    if len(m2) > 2:
        bibitem['journal'] = m2[2]
    if len(m2) > 3:
        bibitem['number'] = m2[3]
    if len(m2) > 4:
        bibitem['pages'] = m2[4]

    return bibitem


def extract_bibitems(filename):
    '''Parses `filename` and returns all bibitems from inside all
    `thebibliography` environments.
    '''
    recording = False
    bibitems = []
    with open(filename, 'r') as f:
        for line in f:
            # Get first non-whitespace character
            m = re.match('^\s*(\S)', line)
            # Skip commented-out lines
            if m and m.group(1) == '%':
                continue
            if '\\begin{thebibliography}' in line:
                recording = True
            if '\\end{thebibliography}' in line:
                recording = False

            if recording:
                if '\\bibitem' in line:
                    # Create new bibitem entry
                    bibitems.append(line)
                elif len(bibitems) > 0:
                    # Append to last bibitem entry
                    bibitems[-1] += line
    return bibitems


def _parse_args():
    parser = argparse.ArgumentParser(description='Extract bibitems.')
    parser.add_argument(
        'input',
        type=str,
        help='input LaTeX file'
        )
    return parser.parse_args()


if __name__ == '__main__':
    _main()
